<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Edge bundling</title>
    <style>
        .link {
            stroke: #69b3a2;
            fill: none;
            stroke-width: 1px;
            opacity: 0.35;
            pointer-events: none;
        }
        circle {
            fill: red;
            stroke: #fff;
            stroke-width: 1px;
            cursor: pointer;
        }
        .tooltip {
            position: absolute;
            background: white;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            pointer-events: none;
            opacity: 0;
        }
        #spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            border: 5px solid #888;
            border-top: 5px solid #555;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            z-index: 9999;
        }
        @keyframes spin {
            0% {
                transform: translate(-50%, -50%) rotate(0deg);
            }
            100% {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }
    </style>
</head>
<body>
    <div id="spinner"></div>
    <svg width="960" height="600"></svg>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/topojson@3"></script>
    <script>
        const svg = d3.select("svg");
        const width = +svg.attr("width");
        const height = +svg.attr("height");
        const tooltip = d3.select("body").append("div").attr("class", "tooltip");

        let bundlingBeta = 0.65;

        const projection = d3.geoAlbersUsa()
            .scale(1300)
            .translate([width / 2, height / 2]);

        const path = d3.geoPath().projection(projection);

        Promise.all([
            d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json"),
            d3.json("https://www.paballand.com/ceps-ai/json/nodes-us.json"),
            d3.json("https://www.paballand.com/ceps-ai/json/links-us.json")
        ]).then(([us, nodesData, linksData]) => {
            svg.append("path")
                .datum(topojson.feature(us, us.objects.nation))
                .attr("fill", "#aaa")
                .attr("d", path);

            svg.append("path")
                .datum(topojson.mesh(us, us.objects.states, (a, b) => a !== b))
                .attr("fill", "none")
                .attr("stroke", "#fff")
                .attr("stroke-width", 0.5)
                .attr("d", path);

            const nodes = nodesData.map(d => {
                const coords = projection([d.y, d.x]);
                return {
                    id: d.id2,
                    name: d.id,
                    parent: d.parent,
                    x: coords[0],
                    y: coords[1],
                    color: d.color,
                    size: d.size
                };
            });

            const links = linksData.map(d => {
                const sourceNode = nodes.find(n => n.id === d.source);
                const targetNode = nodes.find(n => n.id === d.target);
                return {
                    source: sourceNode,
                    target: targetNode,
                    weight: d.weight
                };
            }).filter(d => d.source && d.target);

            let bundle = generateSegments(nodes, links);

            let line = d3.line()
                .curve(d3.curveBundle.beta(bundlingBeta))
                .x(d => d.x)
                .y(d => d.y);

            let link = svg.selectAll(".link")
                .data(bundle.paths)
                .enter()
                .append("path")
                .attr("class", "link")
                .attr("stroke-width", d => Math.sqrt(d.weight || 1));

            svg.selectAll("circle")
                .data(nodes)
                .enter()
                .append("circle")
                .attr("r", d => d.size * 4)
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
                .style("fill", d => d.color)
                .on("mouseover", (event, d) => {
                    tooltip.style("opacity", 1)
                        .html(`${d.parent}<br>${d.name}`)
                        .style("left", (event.pageX + 5) + "px")
                        .style("top", (event.pageY + 5) + "px");
                })
                .on("mousemove", event => {
                    tooltip
                        .style("left", (event.pageX + 5) + "px")
                        .style("top", (event.pageY + 5) + "px");
                })
                .on("mouseout", () => {
                    tooltip.style("opacity", 0);
                })
                .on("click", (event, d) => {
                    highlightLinks(d);
                });

            let simulation = d3.forceSimulation()
                .nodes(bundle.nodes)
                .force("charge", d3.forceManyBody().strength(10).distanceMax(50))
                .force("link", d3.forceLink(bundle.links).strength(0.7).distance(0));

            simulation.stop();

            let iterations = 300;
            for (let i = 0; i < iterations; i++) {
                simulation.tick();
            }

            link.attr("d", line);

            d3.select("#spinner").style("display", "none");

            function highlightLinks(clickedNode) {
                link.each(function(d) {
                    const isActive = d.source === clickedNode;
                    d3.select(this)
                        .attr("stroke", isActive ? "#69b3a2" : "#999")
                        .attr("opacity", isActive ? 1 : 0.3);
                });
            }

            function generateSegments(nodes, links) {
                let bundle = { nodes: [], links: [], paths: [] };
                bundle.nodes = nodes.map(d => {
                    d.fx = d.x;
                    d.fy = d.y;
                    return d;
                });
                links.forEach(d => {
                    let length = distance(d.source, d.target);
                    let total = Math.max(1, Math.round(length / 50));
                    let xscale = d3.scaleLinear()
                        .domain([0, total + 1])
                        .range([d.source.x, d.target.x]);
                    let yscale = d3.scaleLinear()
                        .domain([0, total + 1])
                        .range([d.source.y, d.target.y]);
                    let source = d.source;
                    let target = null;
                    let local = [source];
                    for (let j = 1; j <= total; j++) {
                        target = { x: xscale(j), y: yscale(j) };
                        local.push(target);
                        bundle.nodes.push(target);
                        bundle.links.push({ source: source, target: target });
                        source = target;
                    }
                    local.push(d.target);
                    bundle.links.push({ source: target, target: d.target });
                    local.weight = d.weight;
                    local.source = d.source;
                    local.target = d.target;
                    bundle.paths.push(local);
                });
                return bundle;
            }

            function distance(a, b) {
                const dx = b.x - a.x;
                const dy = b.y - a.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }).catch(err => {
            console.error("Error loading data:", err);
        });
    </script>
</body>
</html>