<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Edge Bundling</title>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }
        #container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        #controlsContainer {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.8);
            padding: 5px;
            border-radius: 4px;
            font-family: sans-serif;
        }
        #spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            border: 5px solid #444;
            border-top: 5px solid #888;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            z-index: 9999;
        }
        @keyframes spin {
            0% {
                transform: translate(-50%, -50%) rotate(0deg);
            }
            100% {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }
        svg {
            width: 100%;
            height: 100%;
            background: #ADD8E6;
            display: block;
        }
        .land {
            fill: #fff;
        }
        .link {
            fill: none;
            stroke: #69b3a2;
            opacity: 0.2;
            pointer-events: none;
        }
        circle {
            fill: red;
            stroke: #fff;
            stroke-width: 1px;
            cursor: pointer;
        }
        .tooltip {
            position: absolute;
            background: white;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            pointer-events: none;
            opacity: 0;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controlsContainer">
            <div>
                <label for="linkThickness">Link Thickness</label>
                <input type="range" id="linkThickness" min="0.1" max="5" step="0.1" value="1">
                <span id="linkThicknessValue">1</span>
            </div>
            <div>
                <label for="bundlingBeta">Bundling Beta</label>
                <input type="range" id="bundlingBeta" min="0" max="1" step="0.01" value="0.65">
                <span id="bundlingBetaValue">0.65</span>
            </div>
            <div>
                <label for="weightEmphasis">Weight Emphasis</label>
                <input type="range" id="weightEmphasis" min="0" max="2" step="0.1" value="1">
                <span id="weightEmphasisValue">1</span>
            </div>
        </div>
        <div id="spinner"></div>
        <svg></svg>
    </div>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/topojson@3"></script>
    <script>
        const svg = d3.select("svg")
        const width = window.innerWidth
        const height = window.innerHeight
        const tooltip = d3.select("body").append("div").attr("class", "tooltip")

        const mapLayer = svg.append("g").attr("id", "mapLayer")
        const linkLayer = svg.append("g").attr("id", "linkLayer")
        const nodeLayer = svg.append("g").attr("id", "nodeLayer")

        let bundlingBeta = 0.65
        let baseThickness = 1
        let weightEmphasis = 1
        let currentlySelectedNode = null

        const projection = d3.geoAlbersUsa()
            .scale(1300)
            .translate([width / 2, height / 2])

        const path = d3.geoPath().projection(projection)

        let linkSelection
        let line = d3.line()
            .curve(d3.curveBundle.beta(bundlingBeta))
            .x(d => d.x)
            .y(d => d.y)

        Promise.all([
            d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json"),
            d3.json("https://www.paballand.com/ceps-ai/json/nodes-us.json"),
            d3.json("https://www.paballand.com/ceps-ai/json/links-us.json")
        ]).then(([us, nodesData, linksData]) => {
            mapLayer.append("path")
                .datum(topojson.feature(us, us.objects.nation))
                .attr("class", "land")
                .attr("d", path)

            mapLayer.append("path")
                .datum(topojson.mesh(us, us.objects.states, (a, b) => a !== b))
                .attr("fill", "none")
                .attr("stroke", "#999")
                .attr("stroke-width", 0.5)
                .attr("d", path)

            const nodes = nodesData.map(d => {
                const coords = projection([d.y, d.x])
                return {
                    id: d.id2,
                    name: d.id,
                    parent: d.parent,
                    x: coords[0],
                    y: coords[1],
                    color: d.color,
                    size: d.size,
                    weightSum: 0
                }
            })

            const links = linksData
                .map(d => {
                    const sourceNode = nodes.find(n => n.id === d.source)
                    const targetNode = nodes.find(n => n.id === d.target)
                    return {
                        source: sourceNode,
                        target: targetNode,
                        weight: d.weight
                    }
                })
                .filter(d => d.source && d.target)

            links.forEach(l => {
                l.source.weightSum += l.weight
                l.target.weightSum += l.weight
            })

            let bundle = generateSegments(nodes, links)

            linkSelection = linkLayer.selectAll(".link")
                .data(bundle.paths)
                .enter()
                .append("path")
                .attr("class", "link")
                .attr("stroke-width", d => {
                    let logVal = Math.log(1 + d.weight)
                    let emphasisVal = Math.pow(logVal, weightEmphasis)
                    return baseThickness * (0.5 + 0.5 * emphasisVal)
                })
                .attr("d", line)

            nodeLayer.selectAll("circle")
                .data(nodes)
                .enter()
                .append("circle")
                .attr("r", d => d.size + Math.log(1 + d.weightSum))
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
                .style("fill", d => d.color)
                .on("mouseover", (event, d) => {
                    tooltip
                        .style("opacity", 1)
                        .html(d.parent + "<br>" + d.name)
                        .style("left", (event.pageX + 5) + "px")
                        .style("top", (event.pageY + 5) + "px")
                })
                .on("mousemove", event => {
                    tooltip
                        .style("left", (event.pageX + 5) + "px")
                        .style("top", (event.pageY + 5) + "px")
                })
                .on("mouseout", () => {
                    tooltip.style("opacity", 0)
                })
                .on("click", (event, d) => {
                    event.stopPropagation()
                    if (currentlySelectedNode && currentlySelectedNode.id === d.id) {
                        resetHighlights()
                        currentlySelectedNode = null
                    } else {
                        highlightLinks(d)
                        currentlySelectedNode = d
                    }
                })

            let simulation = d3.forceSimulation()
                .nodes(bundle.nodes)
                .force("charge", d3.forceManyBody().strength(10).distanceMax(50))
                .force("link", d3.forceLink(bundle.links).strength(0.7).distance(0))

            simulation.stop()
            for (let i = 0; i < 300; i++) {
                simulation.tick()
            }

            d3.select("#spinner").style("display", "none")

            function highlightLinks(clickedNode) {
                linkSelection.each(function(d) {
                    const isActive =
                        d.originalSource.id === clickedNode.id ||
                        d.originalTarget.id === clickedNode.id

                    if (isActive) {
                        linkLayer.node().appendChild(this)
                        d3.select(this)
                            .attr("stroke", "#69b3a2")
                            .attr("opacity", 1)
                    } else {
                        d3.select(this)
                            .attr("stroke", "#999")
                            .attr("opacity", 0)
                    }
                })
                nodeLayer.selectAll("circle")
                    .attr("stroke", n => n.id === clickedNode.id ? "yellow" : "#fff")
                    .attr("stroke-width", n => n.id === clickedNode.id ? 2 : 1)
            }

            function resetHighlights() {
                linkSelection
                    .attr("stroke", "#69b3a2")
                    .attr("opacity", 0.2)
                nodeLayer.selectAll("circle")
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 1)
            }

            function generateSegments(nodes, links) {
                let bundle = { nodes: [], links: [], paths: [] }
                bundle.nodes = nodes.map(d => {
                    d.fx = d.x
                    d.fy = d.y
                    return d
                })
                links.forEach(d => {
                    let length = distance(d.source, d.target)
                    let total = Math.max(1, Math.round(length / 50))
                    let xscale = d3.scaleLinear()
                        .domain([0, total + 1])
                        .range([d.source.x, d.target.x])
                    let yscale = d3.scaleLinear()
                        .domain([0, total + 1])
                        .range([d.source.y, d.target.y])

                    let source = d.source
                    let target = null
                    let local = [source]
                    for (let j = 1; j <= total; j++) {
                        target = { x: xscale(j), y: yscale(j) }
                        local.push(target)
                        bundle.nodes.push(target)
                        bundle.links.push({ source: source, target: target })
                        source = target
                    }
                    local.push(d.target)
                    bundle.links.push({ source: target, target: d.target })

                    local.weight = d.weight
                    local.originalSource = d.source
                    local.originalTarget = d.target

                    bundle.paths.push(local)
                })
                return bundle
            }

            function distance(a, b) {
                const dx = b.x - a.x
                const dy = b.y - a.y
                return Math.sqrt(dx * dx + dy * dy)
            }
        }).catch(err => {
            console.error("Error loading data:", err)
        })

        d3.select("#linkThickness").on("input", function() {
            baseThickness = +this.value
            document.getElementById("linkThicknessValue").textContent = this.value
            if (linkSelection) {
                linkSelection.attr("stroke-width", d => {
                    let logVal = Math.log(1 + d.weight)
                    let emphasisVal = Math.pow(logVal, weightEmphasis)
                    return baseThickness * (0.5 + 0.5 * emphasisVal)
                })
            }
        })

        d3.select("#bundlingBeta").on("input", function() {
            bundlingBeta = +this.value
            document.getElementById("bundlingBetaValue").textContent = this.value
            line.curve(d3.curveBundle.beta(bundlingBeta))
            if (linkSelection) {
                linkSelection.attr("d", line)
            }
        })

        d3.select("#weightEmphasis").on("input", function() {
            weightEmphasis = +this.value
            document.getElementById("weightEmphasisValue").textContent = this.value
            if (linkSelection) {
                linkSelection.attr("stroke-width", d => {
                    let logVal = Math.log(1 + d.weight)
                    let emphasisVal = Math.pow(logVal, weightEmphasis)
                    return baseThickness * (0.5 + 0.5 * emphasisVal)
                })
            }
        })
    </script>
</body>
</html>